-- File: ../vhdl/video_controller/vga_top_level.vhd
-- Generated by MyHDL 0.11
-- Date: Tue Jan  4 18:58:36 2022


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity vga_top_level is
    port (
        vga_in_x_pos: in std_logic_vector(6 downto 0);
        vga_in_y_pos: in std_logic_vector(5 downto 0);
        ram_module_conc0_din: in std_logic;
        ram_module_conc0_clk: in std_logic;
        ram_module_conc0_we: in std_logic;
        vga_in_nrst: in std_logic;
        vga_out_vga_r: out std_logic_vector(7 downto 0);
        vga_out_vga_g: out std_logic_vector(7 downto 0);
        vga_out_vga_b: out std_logic_vector(7 downto 0);
        vga_out_vga_clk: out std_logic;
        vga_out_vga_sync_n: out std_logic;
        vga_out_vga_blank_n: out std_logic;
        vga_out_vga_vs: out std_logic;
        vga_out_vga_hs: out std_logic
    );
end entity vga_top_level;


architecture MyHDL of vga_top_level is



signal ram_address_read: unsigned(12 downto 0);
signal ram_address_write: unsigned(12 downto 0);
signal ram_output: std_logic;
signal vga_output: unsigned(2 downto 0);
signal x_counter: unsigned(9 downto 0);
signal y_counter: unsigned(9 downto 0);
signal clk_25mhz: std_logic;
signal vga_in_x_pos_num: unsigned(6 downto 0);
signal vga_in_y_pos_num: unsigned(5 downto 0);
signal vga_out_vga_r_num: unsigned(7 downto 0);
signal vga_out_vga_g_num: unsigned(7 downto 0);
signal vga_out_vga_b_num: unsigned(7 downto 0);
type t_array_ram_module_conc0_mem is array(0 to 4800-1) of std_logic;
signal ram_module_conc0_mem: t_array_ram_module_conc0_mem;

begin

vga_in_x_pos_num <= unsigned(vga_in_x_pos);
vga_in_y_pos_num <= unsigned(vga_in_y_pos);
vga_out_vga_r <= std_logic_vector(vga_out_vga_r_num);
vga_out_vga_g <= std_logic_vector(vga_out_vga_g_num);
vga_out_vga_b <= std_logic_vector(vga_out_vga_b_num);



-- Convert x position and y position to address 
VGA_TOP_LEVEL_CALC_RAM_ADDRESS: process (vga_in_y_pos_num, vga_in_x_pos_num) is
begin
    if ((signed(resize(vga_in_x_pos_num, 8)) < (80 - 1)) and (signed(resize(vga_in_y_pos_num, 7)) < (60 - 1))) then
        ram_address_write <= (resize(vga_in_x_pos_num, 13) + resize(resize(vga_in_y_pos_num, 7) * 80, 13));
    else
        -- Set to zero if x_pos and y_pos are not valid 
        ram_address_write <= to_unsigned(0, 13);
    end if;
end process VGA_TOP_LEVEL_CALC_RAM_ADDRESS;

-- Clock divider (div2) to get a 25 MHz clock 
VGA_TOP_LEVEL_CLOCK_DIVIDER: process (ram_module_conc0_clk) is
begin
    if rising_edge(ram_module_conc0_clk) then
        clk_25mhz <= stdl((not bool(clk_25mhz)));
    end if;
end process VGA_TOP_LEVEL_CLOCK_DIVIDER;

-- The counter increments the x and y counter. These are free running around the through screen 
VGA_TOP_LEVEL_POS_COUNTER: process (clk_25mhz, vga_in_nrst) is
begin
    if (vga_in_nrst = '0') then
        x_counter <= to_unsigned(0, 10);
        y_counter <= to_unsigned(0, 10);
    elsif rising_edge(clk_25mhz) then
        if (signed(resize(x_counter, 11)) < (800 - 1)) then
            x_counter <= (x_counter + 1);
        else
            x_counter <= to_unsigned(0, 10);
            if (signed(resize(y_counter, 11)) < (524 - 1)) then
                y_counter <= (y_counter + 1);
            else
                y_counter <= to_unsigned(0, 10);
            end if;
        end if;
    end if;
end process VGA_TOP_LEVEL_POS_COUNTER;

-- Write to RAM on positive edge of the clock.
-- This function is secured to not write to unexisting locations
VGA_TOP_LEVEL_RAM_MODULE_CONC0_WRITE_HANDLE: process (ram_module_conc0_clk, vga_in_nrst) is
begin
    if (vga_in_nrst = '0') then
        for i in 0 to 4800-1 loop
            ram_module_conc0_mem(i) <= '0';
        end loop;
    elsif rising_edge(ram_module_conc0_clk) then
        if (ram_module_conc0_we = '1') then
            if (signed(resize(ram_address_write, 14)) < 4800) then
                ram_module_conc0_mem(to_integer(ram_address_write)) <= ram_module_conc0_din;
            else
                ram_module_conc0_mem((4800 - 1)) <= ram_module_conc0_din;
            end if;
        end if;
    end if;
end process VGA_TOP_LEVEL_RAM_MODULE_CONC0_WRITE_HANDLE;


ram_output <= ram_module_conc0_mem(to_integer(ram_address_read));

-- Generate VGA clock with clock divider (DIV2) and hang blank and sync to VCC 

vga_out_vga_blank_n <= '1';
vga_out_vga_sync_n <= '1';
vga_out_vga_clk <= clk_25mhz;

-- Converts 3 bits to 24 color bits 
VGA_TOP_LEVEL_COLOR_CONVERTER: process (vga_output) is
begin
    if (vga_output(2) = '1') then
        vga_out_vga_r_num <= to_unsigned(255, 8);
    else
        vga_out_vga_r_num <= to_unsigned(0, 8);
    end if;
    if (vga_output(1) = '1') then
        vga_out_vga_g_num <= to_unsigned(255, 8);
    else
        vga_out_vga_g_num <= to_unsigned(0, 8);
    end if;
    if (vga_output(0) = '1') then
        vga_out_vga_b_num <= to_unsigned(255, 8);
    else
        vga_out_vga_b_num <= to_unsigned(0, 8);
    end if;
end process VGA_TOP_LEVEL_COLOR_CONVERTER;

-- Translate x and y counter to ram address. The counter value is divided by 8 to ensure a match with the input of 80x60
VGA_TOP_LEVEL_CONTROL_RAM_READ: process (y_counter, x_counter) is
begin
    if ((x_counter < 640) and (y_counter < 480)) then
        ram_address_read <= resize((80 * shift_right(y_counter, 3)) + shift_right(x_counter, 3), 13);
    else
        ram_address_read <= to_unsigned(0, 13);
    end if;
end process VGA_TOP_LEVEL_CONTROL_RAM_READ;

-- Control the vertical sync line 
VGA_TOP_LEVEL_VSYNC_CONTROL: process (y_counter) is
begin
    if ((signed(resize(y_counter, 11)) >= (480 + 11)) and (signed(resize(y_counter, 11)) < ((480 + 11) + 2))) then
        vga_out_vga_vs <= '0';
    else
        vga_out_vga_vs <= '1';
    end if;
end process VGA_TOP_LEVEL_VSYNC_CONTROL;

-- Control the horizontal sync line 
VGA_TOP_LEVEL_HSYNC_CONTROL: process (x_counter) is
begin
    if ((signed(resize(x_counter, 11)) >= (640 + 16)) and (signed(resize(x_counter, 11)) < ((640 + 16) + 96))) then
        vga_out_vga_hs <= '0';
    else
        vga_out_vga_hs <= '1';
    end if;
end process VGA_TOP_LEVEL_HSYNC_CONTROL;

-- Control video output 
VGA_TOP_LEVEL_VIDEO_CONTROL: process (y_counter, ram_output, x_counter) is
begin
    if ((x_counter < 640) and (y_counter < 480)) then
        if (ram_output = '1') then
            vga_output <= to_unsigned(7, 3);
        else
            vga_output <= to_unsigned(0, 3);
        end if;
    else
        vga_output <= to_unsigned(0, 3);
    end if;
end process VGA_TOP_LEVEL_VIDEO_CONTROL;

end architecture MyHDL;
