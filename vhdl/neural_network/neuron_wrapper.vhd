-- File: ../vhdl/neural_network/neuron_wrapper.vhd
-- Generated by MyHDL 0.11
-- Date: Wed Jan 19 13:26:15 2022


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity neuron_wrapper is
    port (
        o: out std_logic_vector(31 downto 0);
        in2: in std_logic_vector(31 downto 0);
        in1: in std_logic_vector(31 downto 0);
        in3: in std_logic_vector(31 downto 0);
        in4: in std_logic_vector(31 downto 0);
        in5: in std_logic_vector(31 downto 0);
        w1: in std_logic_vector(31 downto 0);
        w2: in std_logic_vector(31 downto 0);
        w3: in std_logic_vector(31 downto 0);
        w4: in std_logic_vector(31 downto 0);
        w5: in std_logic_vector(31 downto 0)
    );
end entity neuron_wrapper;


architecture MyHDL of neuron_wrapper is



signal o_num: signed (31 downto 0);
signal in2_num: signed (31 downto 0);
signal in1_num: signed (31 downto 0);
signal in3_num: signed (31 downto 0);
signal in4_num: signed (31 downto 0);
signal in5_num: signed (31 downto 0);
signal w1_num: signed (31 downto 0);
signal w2_num: signed (31 downto 0);
signal w3_num: signed (31 downto 0);
signal w4_num: signed (31 downto 0);
signal w5_num: signed (31 downto 0);
signal neuron1_sum_output: signed (65 downto 0);
signal neuron1_parallel_multiplier1_multiplier6_output: signed (31 downto 0);
signal neuron1_parallel_multiplier1_multiplier7_output: signed (31 downto 0);
signal neuron1_parallel_multiplier1_multiplier8_output: signed (31 downto 0);
signal neuron1_parallel_multiplier1_multiplier9_output: signed (31 downto 0);
signal neuron1_parallel_multiplier1_multiplier10_output: signed (31 downto 0);
signal neuron1_list_adder1_adder5_c: signed (32 downto 0);
signal neuron1_list_adder1_adder6_c: signed (33 downto 0);
signal neuron1_list_adder1_adder7_c: signed (33 downto 0);

begin

o <= std_logic_vector(o_num);
in2_num <= signed (in2);
in1_num <= signed (in1);
in3_num <= signed (in3);
in4_num <= signed (in4);
in5_num <= signed (in5);
w1_num <= signed (w1);
w2_num <= signed (w2);
w3_num <= signed (w3);
w4_num <= signed (w4);
w5_num <= signed (w5);



-- Ramp activation function
NEURON_WRAPPER_NEURON1_RAMP_ACTIVATION1_LOGIC: process (neuron1_sum_output) is
begin
    if (neuron1_sum_output >= 0) then
        o_num <= tern_op(cond => (neuron1_sum_output > 1024), if_true => to_signed(1024, 32), if_false => resize(neuron1_sum_output, 32));
    else
        o_num <= to_signed(0, 32);
    end if;
end process NEURON_WRAPPER_NEURON1_RAMP_ACTIVATION1_LOGIC;

-- Single multiplier 
NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER6_LOGIC: process (in1_num, w1_num) is
    variable product: integer;
begin
    product := to_integer((in1_num * w1_num) / 1024);
    neuron1_parallel_multiplier1_multiplier6_output <= to_signed(product, 32);
end process NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER6_LOGIC;

-- Single multiplier 
NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER7_LOGIC: process (in2_num, w2_num) is
    variable product: integer;
begin
    product := to_integer((in2_num * w2_num) / 1024);
    neuron1_parallel_multiplier1_multiplier7_output <= to_signed(product, 32);
end process NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER7_LOGIC;

-- Single multiplier 
NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER8_LOGIC: process (in3_num, w3_num) is
    variable product: integer;
begin
    product := to_integer((in3_num * w3_num) / 1024);
    neuron1_parallel_multiplier1_multiplier8_output <= to_signed(product, 32);
end process NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER8_LOGIC;

-- Single multiplier 
NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER9_LOGIC: process (in4_num, w4_num) is
    variable product: integer;
begin
    product := to_integer((in4_num * w4_num) / 1024);
    neuron1_parallel_multiplier1_multiplier9_output <= to_signed(product, 32);
end process NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER9_LOGIC;

-- Single multiplier 
NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER10_LOGIC: process (in5_num, w5_num) is
    variable product: integer;
begin
    product := to_integer((in5_num * w5_num) / 1024);
    neuron1_parallel_multiplier1_multiplier10_output <= to_signed(product, 32);
end process NEURON_WRAPPER_NEURON1_PARALLEL_MULTIPLIER1_MULTIPLIER10_LOGIC;

-- Single adder 
NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER5_LOGIC: process (neuron1_parallel_multiplier1_multiplier6_output, neuron1_parallel_multiplier1_multiplier7_output) is
    variable sum: integer;
begin
    sum := to_integer(neuron1_parallel_multiplier1_multiplier6_output + neuron1_parallel_multiplier1_multiplier7_output);
    neuron1_list_adder1_adder5_c <= to_signed(sum, 33);
end process NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER5_LOGIC;

-- Single adder 
NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER6_LOGIC: process (neuron1_parallel_multiplier1_multiplier8_output, neuron1_list_adder1_adder5_c) is
    variable sum: integer;
begin
    sum := to_integer(neuron1_parallel_multiplier1_multiplier8_output + neuron1_list_adder1_adder5_c);
    neuron1_list_adder1_adder6_c <= to_signed(sum, 34);
end process NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER6_LOGIC;

-- Single adder 
NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER7_LOGIC: process (neuron1_parallel_multiplier1_multiplier9_output, neuron1_list_adder1_adder6_c) is
    variable sum: integer;
begin
    sum := to_integer(neuron1_parallel_multiplier1_multiplier9_output + neuron1_list_adder1_adder6_c);
    neuron1_list_adder1_adder7_c <= to_signed(sum, 34);
end process NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER7_LOGIC;

-- Single adder 
NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER8_LOGIC: process (neuron1_parallel_multiplier1_multiplier10_output, neuron1_list_adder1_adder7_c) is
    variable sum: integer;
begin
    sum := to_integer(neuron1_parallel_multiplier1_multiplier10_output + neuron1_list_adder1_adder7_c);
    neuron1_sum_output <= to_signed(sum, 66);
end process NEURON_WRAPPER_NEURON1_LIST_ADDER1_ADDER8_LOGIC;

end architecture MyHDL;
