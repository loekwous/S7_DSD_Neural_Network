-- File: vhdl_out/codec_top_level.vhd
-- Generated by MyHDL 0.11
-- Date: Tue Jan 25 21:06:55 2022


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity codec_top_level is
    port (
        clk: in std_logic;
        nrst: in std_logic;
        start: in std_logic;
        ready: out std_logic;
        i2c_success: in std_logic;
        i2c_start: out std_logic;
        i2c_ready: in std_logic;
        i2c_address: out std_logic_vector(6 downto 0);
        i2c_rw: out std_logic;
        i2c_data: out std_logic_vector(7 downto 0);
        i2c_data_address: out std_logic_vector(7 downto 0)
    );
end entity codec_top_level;


architecture MyHDL of codec_top_level is


type t_enum_t_states_1 is (
	IDLE,
	WF_START,
	START_SENDING,
	WAIT_FOR_TRANS,
	COUNT_UP
	);

signal i2c_address_num: unsigned(6 downto 0);
signal i2c_data_num: unsigned(7 downto 0);
signal i2c_data_address_num: unsigned(7 downto 0);
signal cnt_clear: std_logic;
signal cnt_up: std_logic;
signal cnt_top: std_logic;
signal count_sig: unsigned(1 downto 0);
signal counter1_count_sig: unsigned(1 downto 0);
signal codec_controller1_n_s: t_enum_t_states_1;
signal codec_controller1_p_s: t_enum_t_states_1;

begin

i2c_address <= std_logic_vector(i2c_address_num);
i2c_data <= std_logic_vector(i2c_data_num);
i2c_data_address <= std_logic_vector(i2c_data_address_num);



CODEC_TOP_LEVEL_COUNTER1_TOP_LOGIC: process (counter1_count_sig) is
begin
    if (counter1_count_sig = 3) then
        cnt_top <= '1';
    else
        cnt_top <= '0';
    end if;
end process CODEC_TOP_LEVEL_COUNTER1_TOP_LOGIC;


count_sig <= counter1_count_sig;

CODEC_TOP_LEVEL_COUNTER1_COUNT_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (cnt_clear = '1') then
            counter1_count_sig <= to_unsigned(0, 2);
        else
            if ((cnt_up = '1') and (counter1_count_sig < 3)) then
                counter1_count_sig <= (counter1_count_sig + 1);
            end if;
        end if;
    end if;
end process CODEC_TOP_LEVEL_COUNTER1_COUNT_LOGIC;

CODEC_TOP_LEVEL_ROM_CONTENT1_LOGIC: process (count_sig) is
begin
    i2c_rw <= '0';
    i2c_address_num <= to_unsigned(26, 7);
    case to_integer(count_sig) is
        when 0 => i2c_data_address_num <= "00000000";
        when 1 => i2c_data_address_num <= "00000010";
        when 2 => i2c_data_address_num <= "00001100";
        when others => i2c_data_address_num <= "00010010";
    end case;
    case to_integer(count_sig) is
        when 0 => i2c_data_num <= "00010111";
        when 1 => i2c_data_num <= "00010111";
        when 2 => i2c_data_num <= "00001010";
        when others => i2c_data_num <= "00000001";
    end case;
end process CODEC_TOP_LEVEL_ROM_CONTENT1_LOGIC;

CODEC_TOP_LEVEL_CODEC_CONTROLLER1_INPUT_DECODER: process (i2c_ready, codec_controller1_p_s, i2c_success, cnt_top, start) is
begin
    if ((codec_controller1_p_s = IDLE) and (start = '1')) then
        codec_controller1_n_s <= WF_START;
    elsif ((codec_controller1_p_s = WF_START) and (start = '0')) then
        codec_controller1_n_s <= START_SENDING;
    elsif ((codec_controller1_p_s = START_SENDING) and (i2c_ready = '0')) then
        codec_controller1_n_s <= WAIT_FOR_TRANS;
    elsif (codec_controller1_p_s = WAIT_FOR_TRANS) then
        if (i2c_ready = '1') then
            if (i2c_success = '1') then
                if (cnt_top = '1') then
                    codec_controller1_n_s <= IDLE;
                else
                    codec_controller1_n_s <= COUNT_UP;
                end if;
            else
                codec_controller1_n_s <= IDLE;
            end if;
        else
            codec_controller1_n_s <= WAIT_FOR_TRANS;
        end if;
    elsif (codec_controller1_p_s = COUNT_UP) then
        codec_controller1_n_s <= START_SENDING;
    else
        codec_controller1_n_s <= codec_controller1_p_s;
    end if;
end process CODEC_TOP_LEVEL_CODEC_CONTROLLER1_INPUT_DECODER;

CODEC_TOP_LEVEL_CODEC_CONTROLLER1_MEMORY: process (clk, nrst) is
begin
    if (nrst = '0') then
        codec_controller1_p_s <= IDLE;
    elsif rising_edge(clk) then
        codec_controller1_p_s <= codec_controller1_n_s;
    end if;
end process CODEC_TOP_LEVEL_CODEC_CONTROLLER1_MEMORY;


i2c_start <= tern_op(cond => (codec_controller1_p_s = START_SENDING), if_true => '1', if_false => '0');

CODEC_TOP_LEVEL_CODEC_CONTROLLER1_CLEAR_CONTROL: process (codec_controller1_p_s) is
    variable clear_condition: std_logic;
begin
    clear_condition := stdl((codec_controller1_p_s = IDLE) or (codec_controller1_p_s = WF_START));
    cnt_clear <= tern_op(cond => bool(clear_condition), if_true => '1', if_false => '0');
end process CODEC_TOP_LEVEL_CODEC_CONTROLLER1_CLEAR_CONTROL;


cnt_up <= tern_op(cond => (codec_controller1_p_s = COUNT_UP), if_true => '1', if_false => '0');


ready <= tern_op(cond => (codec_controller1_p_s = IDLE), if_true => '1', if_false => '0');

end architecture MyHDL;
