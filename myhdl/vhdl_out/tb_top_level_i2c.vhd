-- File: vhdl_out/tb_top_level_i2c.vhd
-- Generated by MyHDL 0.11
-- Date: Wed Jan 26 10:14:57 2022


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity tb_top_level_i2c is
end entity tb_top_level_i2c;


architecture MyHDL of tb_top_level_i2c is


type t_enum_t_states_1 is (
	IDLE,
	WF_START,
	START1,
	START2,
	SEND_ADDR,
	CHECK_ACK_S0,
	CHECK_ACK_S1,
	CHECK_ACK_S2,
	SEND_DATA_ADDRESS,
	CHECK_ACK_S3,
	CHECK_ACK_S4,
	CHECK_ACK_S5,
	SEND_DATA,
	CHECK_ACK_S6,
	CHECK_ACK_S7,
	CHECK_ACK_S8,
	STOP_S0,
	STOP_S1
	);

signal rw: std_logic;
signal success: std_logic;
signal SDA: std_logic;
signal SCL: std_logic;
signal read_data: unsigned(7 downto 0);
signal address: unsigned(6 downto 0);
signal clk: std_logic;
signal nrst: std_logic;
signal ready: std_logic;
signal regi_address: unsigned(7 downto 0);
signal regi_data: unsigned(7 downto 0);
signal start: std_logic;
signal driver: std_logic;
signal top_level_i2c2_sel_sig: unsigned(1 downto 0);
signal top_level_i2c2_i2c_clk: std_logic;
signal top_level_i2c2_current_bit: std_logic;
signal top_level_i2c2_count_en: std_logic;
signal top_level_i2c2_count_rdy: std_logic;
signal top_level_i2c2_scl_internal: std_logic;
signal top_level_i2c2_sh_clr: std_logic;
signal top_level_i2c2_sh_en: std_logic;
signal top_level_i2c2_i2c_clk_en: std_logic;
signal top_level_i2c2_bit_select: unsigned(2 downto 0);
signal top_level_i2c2_mux_out: unsigned(7 downto 0);
signal top_level_i2c2_clr_reg: std_logic;
signal top_level_i2c2_en_reg: std_logic;
signal top_level_i2c2_fsm_sel: std_logic;
signal top_level_i2c2_fsm_write: std_logic;
signal top_level_i2c2_fsm_ack: std_logic;
signal top_level_i2c2_fsm_clr_ack: std_logic;
signal top_level_i2c2_success_trigger: std_logic;
signal top_level_i2c2_data_acquisition2_combiner_out: unsigned(7 downto 0);
signal top_level_i2c2_data_acquisition2_i2c_addr_reg_out: unsigned(7 downto 0);
signal top_level_i2c2_data_acquisition2_reg_addr_out: unsigned(7 downto 0);
signal top_level_i2c2_data_acquisition2_reg_data_out: unsigned(7 downto 0);
signal top_level_i2c2_data_acquisition2_reg_data6_reg: unsigned(7 downto 0);
signal top_level_i2c2_data_acquisition2_reg_data7_reg: unsigned(7 downto 0);
signal top_level_i2c2_data_acquisition2_reg_data8_reg: unsigned(7 downto 0);
signal top_level_i2c2_counter2_counter: signed (3 downto 0);
signal top_level_i2c2_output_control2_read_bit: std_logic;
signal top_level_i2c2_output_control2_mux_scl_out: std_logic;
signal top_level_i2c2_output_control2_mux_sda_out: std_logic;
signal top_level_i2c2_output_control2_tri_state_controller2_tri_out_driver: std_logic;
signal top_level_i2c2_output_control2_open_drain_output2_dr: std_logic;
signal top_level_i2c2_output_control2_shift_reg_data2_reg: unsigned(7 downto 0);
signal top_level_i2c2_clock_divider2_clk_out_sig: std_logic;
signal top_level_i2c2_clock_divider2_counter: unsigned(3 downto 0);
signal top_level_i2c2_controller_i2c2_n_s: t_enum_t_states_1;
signal top_level_i2c2_controller_i2c2_p_s: t_enum_t_states_1;

begin


rw <= '0';

SDA <= top_level_i2c2_output_control2_tri_state_controller2_tri_out_driver;
SDA <= driver;
SCL <= top_level_i2c2_output_control2_open_drain_output2_dr;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_SUCCESS_REG2_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (top_level_i2c2_en_reg = '1') then
            success <= '0';
        else
            if (top_level_i2c2_success_trigger = '1') then
                success <= '1';
            end if;
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_SUCCESS_REG2_LOGIC;


top_level_i2c2_data_acquisition2_combiner_out <= unsigned'(address & rw);


top_level_i2c2_data_acquisition2_i2c_addr_reg_out <= top_level_i2c2_data_acquisition2_reg_data6_reg;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_REG_DATA6_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (top_level_i2c2_clr_reg = '1') then
            top_level_i2c2_data_acquisition2_reg_data6_reg <= to_unsigned(0, 8);
        elsif (top_level_i2c2_en_reg = '1') then
            top_level_i2c2_data_acquisition2_reg_data6_reg <= top_level_i2c2_data_acquisition2_combiner_out;
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_REG_DATA6_LOGIC;


top_level_i2c2_data_acquisition2_reg_addr_out <= top_level_i2c2_data_acquisition2_reg_data7_reg;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_REG_DATA7_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (top_level_i2c2_clr_reg = '1') then
            top_level_i2c2_data_acquisition2_reg_data7_reg <= to_unsigned(0, 8);
        elsif (top_level_i2c2_en_reg = '1') then
            top_level_i2c2_data_acquisition2_reg_data7_reg <= regi_address;
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_REG_DATA7_LOGIC;


top_level_i2c2_data_acquisition2_reg_data_out <= top_level_i2c2_data_acquisition2_reg_data8_reg;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_REG_DATA8_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (top_level_i2c2_clr_reg = '1') then
            top_level_i2c2_data_acquisition2_reg_data8_reg <= to_unsigned(0, 8);
        elsif (top_level_i2c2_en_reg = '1') then
            top_level_i2c2_data_acquisition2_reg_data8_reg <= regi_data;
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_REG_DATA8_LOGIC;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_MUX_3INPUT2_LOGIC: process (top_level_i2c2_data_acquisition2_reg_addr_out, top_level_i2c2_sel_sig, top_level_i2c2_data_acquisition2_i2c_addr_reg_out, top_level_i2c2_data_acquisition2_reg_data_out) is
begin
    case top_level_i2c2_sel_sig is
        when "00" =>
            top_level_i2c2_mux_out <= top_level_i2c2_data_acquisition2_i2c_addr_reg_out;
        when "01" =>
            top_level_i2c2_mux_out <= top_level_i2c2_data_acquisition2_reg_addr_out;
        when others =>
            top_level_i2c2_mux_out <= top_level_i2c2_data_acquisition2_reg_data_out;
    end case;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_DATA_ACQUISITION2_MUX_3INPUT2_LOGIC;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_BIT_SELECTOR2_LOGIC: process (top_level_i2c2_bit_select, top_level_i2c2_mux_out) is
    variable value: std_logic;
begin
    value := top_level_i2c2_mux_out(to_integer(top_level_i2c2_bit_select));
    top_level_i2c2_current_bit <= value;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_BIT_SELECTOR2_LOGIC;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_COUNTER2_OUTPUT_LOGIC: process (top_level_i2c2_counter2_counter) is
begin
    if (top_level_i2c2_counter2_counter >= 0) then
        top_level_i2c2_bit_select <= resize(unsigned(top_level_i2c2_counter2_counter), 3);
    else
        top_level_i2c2_bit_select <= to_unsigned(0, 3);
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_COUNTER2_OUTPUT_LOGIC;


top_level_i2c2_count_rdy <= tern_op(cond => (top_level_i2c2_counter2_counter = (- 1)), if_true => '1', if_false => '0');

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_COUNTER2_COUNT_LOGIC: process (top_level_i2c2_i2c_clk) is
begin
    if falling_edge(top_level_i2c2_i2c_clk) then
        if (top_level_i2c2_count_en = '1') then
            if (top_level_i2c2_counter2_counter > (- 1)) then
                top_level_i2c2_counter2_counter <= (top_level_i2c2_counter2_counter - 1);
            end if;
        else
            top_level_i2c2_counter2_counter <= to_signed(7, 4);
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_COUNTER2_COUNT_LOGIC;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_CHECK_ACK2_LOGIC: process (top_level_i2c2_i2c_clk) is
begin
    if rising_edge(top_level_i2c2_i2c_clk) then
        if (top_level_i2c2_fsm_clr_ack = '1') then
            top_level_i2c2_fsm_ack <= '0';
        else
            if (top_level_i2c2_output_control2_read_bit = '0') then
                top_level_i2c2_fsm_ack <= '1';
            else
                top_level_i2c2_fsm_ack <= '0';
            end if;
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_CHECK_ACK2_LOGIC;


top_level_i2c2_output_control2_mux_scl_out <= tern_op(cond => (top_level_i2c2_fsm_sel = '0'), if_true => top_level_i2c2_scl_internal, if_false => top_level_i2c2_i2c_clk);


top_level_i2c2_output_control2_mux_sda_out <= tern_op(cond => (top_level_i2c2_fsm_sel = '0'), if_true => top_level_i2c2_fsm_write, if_false => top_level_i2c2_current_bit);

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_TRI_STATE_CONTROLLER2_CONTROL_OUT: process (SDA) is
begin
    if (SDA = '0') then
        top_level_i2c2_output_control2_read_bit <= '0';
    else
        top_level_i2c2_output_control2_read_bit <= '1';
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_TRI_STATE_CONTROLLER2_CONTROL_OUT;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_TRI_STATE_CONTROLLER2_INPUT_CONTROL: process (top_level_i2c2_output_control2_mux_sda_out) is
begin
    if (top_level_i2c2_output_control2_mux_sda_out = '1') then
        top_level_i2c2_output_control2_tri_state_controller2_tri_out_driver <= 'Z';
    else
        top_level_i2c2_output_control2_tri_state_controller2_tri_out_driver <= '0';
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_TRI_STATE_CONTROLLER2_INPUT_CONTROL;

-- Open drain SCL output
TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_OPEN_DRAIN_OUTPUT2_INPUT_CONTROL: process (top_level_i2c2_output_control2_mux_scl_out, SCL) is
begin
    if ((top_level_i2c2_output_control2_mux_scl_out = '0') and ((SCL = '1') or (SCL = '0') or (SCL = 'Z'))) then
        top_level_i2c2_output_control2_open_drain_output2_dr <= '0';
    else
        top_level_i2c2_output_control2_open_drain_output2_dr <= 'Z';
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_OPEN_DRAIN_OUTPUT2_INPUT_CONTROL;


read_data <= top_level_i2c2_output_control2_shift_reg_data2_reg;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_SHIFT_REG_DATA2_LOGIC: process (top_level_i2c2_i2c_clk) is
    variable val: unsigned(7 downto 0);
begin
    if rising_edge(top_level_i2c2_i2c_clk) then
        if (top_level_i2c2_sh_clr = '1') then
            top_level_i2c2_output_control2_shift_reg_data2_reg <= to_unsigned(0, 8);
        elsif (top_level_i2c2_sh_en = '1') then
            val := top_level_i2c2_output_control2_shift_reg_data2_reg(8-1 downto 0);
            top_level_i2c2_output_control2_shift_reg_data2_reg <= resize(unsigned'(val & top_level_i2c2_output_control2_read_bit), 8);
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_OUTPUT_CONTROL2_SHIFT_REG_DATA2_LOGIC;


top_level_i2c2_i2c_clk <= top_level_i2c2_clock_divider2_clk_out_sig;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CLOCK_DIVIDER2_UPDATE_OUTPUT: process (clk) is
begin
    if rising_edge(clk) then
        if (top_level_i2c2_clock_divider2_counter = 8) then
            if (top_level_i2c2_i2c_clk_en = '1') then
                top_level_i2c2_clock_divider2_clk_out_sig <= stdl((not bool(top_level_i2c2_clock_divider2_clk_out_sig)));
            else
                top_level_i2c2_clock_divider2_clk_out_sig <= '0';
            end if;
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CLOCK_DIVIDER2_UPDATE_OUTPUT;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CLOCK_DIVIDER2_CNT_UPDATE: process (clk) is
begin
    if rising_edge(clk) then
        if (top_level_i2c2_i2c_clk_en = '1') then
            if (top_level_i2c2_clock_divider2_counter < 8) then
                top_level_i2c2_clock_divider2_counter <= (top_level_i2c2_clock_divider2_counter + 1);
            else
                top_level_i2c2_clock_divider2_counter <= to_unsigned(0, 4);
            end if;
        else
            top_level_i2c2_clock_divider2_counter <= to_unsigned(0, 4);
        end if;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CLOCK_DIVIDER2_CNT_UPDATE;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_INPUT_DECODER: process (top_level_i2c2_fsm_ack, top_level_i2c2_count_rdy, start, top_level_i2c2_i2c_clk, top_level_i2c2_controller_i2c2_p_s) is
begin
    if ((top_level_i2c2_controller_i2c2_p_s = IDLE) and (start = '1')) then
        top_level_i2c2_controller_i2c2_n_s <= WF_START;
    elsif ((top_level_i2c2_controller_i2c2_p_s = WF_START) and (start = '0')) then
        top_level_i2c2_controller_i2c2_n_s <= START1;
    elsif ((top_level_i2c2_controller_i2c2_p_s = START1) and (top_level_i2c2_i2c_clk = '1')) then
        top_level_i2c2_controller_i2c2_n_s <= START2;
    elsif ((top_level_i2c2_controller_i2c2_p_s = START2) and (top_level_i2c2_i2c_clk = '0')) then
        top_level_i2c2_controller_i2c2_n_s <= SEND_ADDR;
    elsif ((top_level_i2c2_controller_i2c2_p_s = SEND_ADDR) and (not bool(top_level_i2c2_i2c_clk)) and bool(top_level_i2c2_count_rdy)) then
        top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S0;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S0) and bool(top_level_i2c2_i2c_clk) and bool(top_level_i2c2_count_rdy)) then
        top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S1;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S1) and (not bool(top_level_i2c2_i2c_clk))) then
        if (top_level_i2c2_fsm_ack = '1') then
            top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S2;
        else
            top_level_i2c2_controller_i2c2_n_s <= IDLE;
        end if;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S2) and bool(top_level_i2c2_i2c_clk)) then
        top_level_i2c2_controller_i2c2_n_s <= SEND_DATA_ADDRESS;
    elsif ((top_level_i2c2_controller_i2c2_p_s = SEND_DATA_ADDRESS) and (not bool(top_level_i2c2_i2c_clk)) and bool(top_level_i2c2_count_rdy)) then
        top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S3;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S3) and bool(top_level_i2c2_i2c_clk) and bool(top_level_i2c2_count_rdy)) then
        top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S4;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S4) and (not bool(top_level_i2c2_i2c_clk))) then
        if (top_level_i2c2_fsm_ack = '1') then
            top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S5;
        else
            top_level_i2c2_controller_i2c2_n_s <= IDLE;
        end if;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S5) and bool(top_level_i2c2_i2c_clk)) then
        top_level_i2c2_controller_i2c2_n_s <= SEND_DATA;
    elsif ((top_level_i2c2_controller_i2c2_p_s = SEND_DATA) and (not bool(top_level_i2c2_i2c_clk)) and bool(top_level_i2c2_count_rdy)) then
        top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S6;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S6) and bool(top_level_i2c2_i2c_clk) and bool(top_level_i2c2_count_rdy)) then
        top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S7;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S7) and (not bool(top_level_i2c2_i2c_clk))) then
        if (top_level_i2c2_fsm_ack = '1') then
            top_level_i2c2_controller_i2c2_n_s <= CHECK_ACK_S8;
        else
            top_level_i2c2_controller_i2c2_n_s <= IDLE;
        end if;
    elsif ((top_level_i2c2_controller_i2c2_p_s = CHECK_ACK_S8) and bool(top_level_i2c2_i2c_clk)) then
        top_level_i2c2_controller_i2c2_n_s <= STOP_S0;
    elsif ((top_level_i2c2_controller_i2c2_p_s = STOP_S0) and (not bool(top_level_i2c2_i2c_clk))) then
        top_level_i2c2_controller_i2c2_n_s <= STOP_S1;
    elsif ((top_level_i2c2_controller_i2c2_p_s = STOP_S1) and bool(top_level_i2c2_i2c_clk)) then
        top_level_i2c2_controller_i2c2_n_s <= IDLE;
    else
        top_level_i2c2_controller_i2c2_n_s <= top_level_i2c2_controller_i2c2_p_s;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_INPUT_DECODER;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_MEMORY: process (clk, nrst) is
begin
    if (nrst = '0') then
        top_level_i2c2_controller_i2c2_p_s <= IDLE;
    elsif rising_edge(clk) then
        top_level_i2c2_controller_i2c2_p_s <= top_level_i2c2_controller_i2c2_n_s;
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_MEMORY;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_READY_CONTROL: process (top_level_i2c2_controller_i2c2_p_s) is
    variable cond_ack_0: std_logic;
    variable cond_ack_1: std_logic;
    variable cond_ack_2: std_logic;
begin
    cond_ack_0 := stdl((top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S0) and (top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S1) and (top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S2));
    cond_ack_1 := stdl((top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S3) and (top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S4) and (top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S5));
    cond_ack_2 := stdl((top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S6) and (top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S7) and (top_level_i2c2_controller_i2c2_p_s /= CHECK_ACK_S8));
    top_level_i2c2_fsm_clr_ack <= tern_op(cond => (bool(cond_ack_0) and bool(cond_ack_1) and bool(cond_ack_2)), if_true => '1', if_false => '0');
    if (top_level_i2c2_controller_i2c2_p_s = IDLE) then
        ready <= '1';
    else
        ready <= '0';
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_READY_CONTROL;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_CLEAR_CONTROL: process (top_level_i2c2_controller_i2c2_p_s) is
begin
    if (top_level_i2c2_controller_i2c2_p_s = IDLE) then
        top_level_i2c2_clr_reg <= '1';
        top_level_i2c2_sh_clr <= '1';
    else
        top_level_i2c2_clr_reg <= '0';
        top_level_i2c2_sh_clr <= '0';
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_CLEAR_CONTROL;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_COUNT_CONTROL: process (top_level_i2c2_controller_i2c2_p_s) is
begin
    if (top_level_i2c2_controller_i2c2_p_s = IDLE) then
        top_level_i2c2_count_en <= '0';
    elsif ((top_level_i2c2_controller_i2c2_p_s = SEND_ADDR) or (top_level_i2c2_controller_i2c2_p_s = SEND_DATA_ADDRESS) or (top_level_i2c2_controller_i2c2_p_s = SEND_DATA)) then
        top_level_i2c2_count_en <= '1';
    else
        top_level_i2c2_count_en <= '0';
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_COUNT_CONTROL;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_REG_EN_CONTROL: process (top_level_i2c2_controller_i2c2_p_s) is
begin
    if (top_level_i2c2_controller_i2c2_p_s = WF_START) then
        top_level_i2c2_en_reg <= '1';
    else
        top_level_i2c2_en_reg <= '0';
    end if;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_REG_EN_CONTROL;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_I2C_CONTROL: process (top_level_i2c2_controller_i2c2_p_s) is
begin
    case top_level_i2c2_controller_i2c2_p_s is
        when IDLE =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
        when START1 =>
            top_level_i2c2_fsm_write <= '0';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
        when START2 =>
            top_level_i2c2_fsm_write <= '0';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
        when SEND_ADDR =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '1';
        when CHECK_ACK_S0 =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '0';
            top_level_i2c2_fsm_sel <= '0';
        when CHECK_ACK_S1 =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
        when CHECK_ACK_S2 =>
            top_level_i2c2_fsm_write <= '0';
            top_level_i2c2_scl_internal <= '0';
            top_level_i2c2_fsm_sel <= '0';
        when SEND_DATA_ADDRESS =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '1';
        when CHECK_ACK_S3 =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '0';
            top_level_i2c2_fsm_sel <= '0';
        when CHECK_ACK_S4 =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
        when CHECK_ACK_S5 =>
            top_level_i2c2_fsm_write <= '0';
            top_level_i2c2_scl_internal <= '0';
            top_level_i2c2_fsm_sel <= '0';
        when SEND_DATA =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '1';
        when CHECK_ACK_S6 =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '0';
            top_level_i2c2_fsm_sel <= '0';
        when CHECK_ACK_S7 =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
        when CHECK_ACK_S8 =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '0';
            top_level_i2c2_fsm_sel <= '0';
        when STOP_S0 =>
            top_level_i2c2_fsm_write <= '0';
            top_level_i2c2_scl_internal <= '0';
            top_level_i2c2_fsm_sel <= '0';
        when STOP_S1 =>
            top_level_i2c2_fsm_write <= '0';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
        when others =>
            top_level_i2c2_fsm_write <= '1';
            top_level_i2c2_scl_internal <= '1';
            top_level_i2c2_fsm_sel <= '0';
    end case;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_I2C_CONTROL;

TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_OUTPUT_DECODER: process (top_level_i2c2_controller_i2c2_p_s) is
begin
    case top_level_i2c2_controller_i2c2_p_s is
        when START1 =>
            top_level_i2c2_sel_sig <= to_unsigned(0, 2);
            top_level_i2c2_success_trigger <= '0';
            top_level_i2c2_sh_en <= '0';
            top_level_i2c2_i2c_clk_en <= '1';
        when START2 =>
            top_level_i2c2_sel_sig <= to_unsigned(0, 2);
            top_level_i2c2_success_trigger <= '0';
            top_level_i2c2_sh_en <= '0';
            top_level_i2c2_i2c_clk_en <= '1';
        when SEND_DATA_ADDRESS =>
            top_level_i2c2_sel_sig <= to_unsigned(1, 2);
            top_level_i2c2_success_trigger <= '0';
            top_level_i2c2_sh_en <= '0';
            top_level_i2c2_i2c_clk_en <= '1';
        when SEND_DATA =>
            top_level_i2c2_sel_sig <= to_unsigned(2, 2);
            top_level_i2c2_success_trigger <= '0';
            top_level_i2c2_sh_en <= '0';
            top_level_i2c2_i2c_clk_en <= '1';
        when CHECK_ACK_S8 =>
            top_level_i2c2_sel_sig <= to_unsigned(2, 2);
            top_level_i2c2_success_trigger <= '1';
            top_level_i2c2_sh_en <= '0';
            top_level_i2c2_i2c_clk_en <= '1';
        when others =>
            top_level_i2c2_sel_sig <= to_unsigned(0, 2);
            top_level_i2c2_success_trigger <= '0';
            top_level_i2c2_sh_en <= '0';
            top_level_i2c2_i2c_clk_en <= '1';
    end case;
end process TB_TOP_LEVEL_I2C_TOP_LEVEL_I2C2_CONTROLLER_I2C2_OUTPUT_DECODER;

TB_TOP_LEVEL_I2C_STIMULI: process is
    variable L: line;
    variable clock_counter: integer;
begin
    driver <= 'Z';
    write(L, string'("reset device"));
    writeline(output, L);
    nrst <= '1';
    wait for 10 * 1 ns;
    nrst <= '0';
    wait for 10 * 1 ns;
    nrst <= '1';
    write(L, string'("clueless clocking"));
    writeline(output, L);
    for i in 0 to 200-1 loop
        clk <= '1';
        wait for 10 * 1 ns;
        clk <= '0';
        wait for 10 * 1 ns;
    end loop;
    write(L, string'("setting data and starting process"));
    writeline(output, L);
    address <= to_unsigned(10, 7);
    regi_data <= to_unsigned(20, 8);
    regi_address <= to_unsigned(5, 8);
    start <= '1';
    wait for 10 * 1 ns;
    for i in 0 to 286-1 loop
        clk <= '1';
        wait for 10 * 1 ns;
        clk <= '0';
        if ((ready = '0') and (start = '1')) then
            start <= '0';
            write(L, string'("setting start to false, because ready is also false"));
            writeline(output, L);
        end if;
        if (i = 285) then
            driver <= '0';
        end if;
        wait for 10 * 1 ns;
    end loop;
    write(L, string'("address clocking"));
    writeline(output, L);
    clock_counter := 0;
    while True loop
        clk <= '1';
        wait for 10 * 1 ns;
        clk <= '0';
        if ((clock_counter > 300) and (clock_counter < 320)) then
            driver <= '0';
        elsif ((clock_counter > 610) and (clock_counter < 630)) then
            driver <= '0';
        elsif ((clock_counter > 800) and (clock_counter < 810)) then
            start <= '1';
        elsif ((clock_counter > 810) and (clock_counter < 820)) then
            start <= '0';
        elsif (clock_counter > 8) then
            driver <= 'Z';
        end if;
        if (clock_counter > 1500) then
            exit;
        end if;
        clock_counter := (clock_counter + 1);
        wait for 10 * 1 ns;
    end loop;
    
    wait;
end process TB_TOP_LEVEL_I2C_STIMULI;

end architecture MyHDL;
