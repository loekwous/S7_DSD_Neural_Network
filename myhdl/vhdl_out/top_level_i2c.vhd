-- File: vhdl_out/top_level_i2c.vhd
-- Generated by MyHDL 0.11
-- Date: Wed Jan 26 10:14:56 2022


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity top_level_i2c is
    port (
        start: in std_logic;
        regi_data: in std_logic_vector(7 downto 0);
        regi_address: in std_logic_vector(7 downto 0);
        rw: in std_logic;
        address: in std_logic_vector(6 downto 0);
        clk: in std_logic;
        nrst: in std_logic;
        ready: out std_logic;
        success: out std_logic;
        SDA: inout std_logic;
        SCL: inout std_logic;
        read_data: out std_logic_vector(7 downto 0)
    );
end entity top_level_i2c;


architecture MyHDL of top_level_i2c is


type t_enum_t_states_1 is (
	IDLE,
	WF_START,
	START1,
	START2,
	SEND_ADDR,
	CHECK_ACK_S0,
	CHECK_ACK_S1,
	CHECK_ACK_S2,
	SEND_DATA_ADDRESS,
	CHECK_ACK_S3,
	CHECK_ACK_S4,
	CHECK_ACK_S5,
	SEND_DATA,
	CHECK_ACK_S6,
	CHECK_ACK_S7,
	CHECK_ACK_S8,
	STOP_S0,
	STOP_S1
	);

signal regi_data_num: unsigned(7 downto 0);
signal regi_address_num: unsigned(7 downto 0);
signal address_num: unsigned(6 downto 0);
signal read_data_num: unsigned(7 downto 0);
signal sel_sig: unsigned(1 downto 0);
signal i2c_clk: std_logic;
signal current_bit: std_logic;
signal count_en: std_logic;
signal count_rdy: std_logic;
signal scl_internal: std_logic;
signal sh_clr: std_logic;
signal sh_en: std_logic;
signal i2c_clk_en: std_logic;
signal bit_select: unsigned(2 downto 0);
signal mux_out: unsigned(7 downto 0);
signal clr_reg: std_logic;
signal en_reg: std_logic;
signal fsm_sel: std_logic;
signal fsm_write: std_logic;
signal fsm_ack: std_logic;
signal fsm_clr_ack: std_logic;
signal success_trigger: std_logic;
signal data_acquisition1_combiner_out: unsigned(7 downto 0);
signal data_acquisition1_i2c_addr_reg_out: unsigned(7 downto 0);
signal data_acquisition1_reg_addr_out: unsigned(7 downto 0);
signal data_acquisition1_reg_data_out: unsigned(7 downto 0);
signal data_acquisition1_reg_data3_reg: unsigned(7 downto 0);
signal data_acquisition1_reg_data4_reg: unsigned(7 downto 0);
signal data_acquisition1_reg_data5_reg: unsigned(7 downto 0);
signal counter1_counter: signed (3 downto 0);
signal output_control1_read_bit: std_logic;
signal output_control1_mux_scl_out: std_logic;
signal output_control1_mux_sda_out: std_logic;
signal output_control1_tri_state_controller1_tri_out_driver: std_logic;
signal output_control1_open_drain_output1_dr: std_logic;
signal output_control1_shift_reg_data1_reg: unsigned(7 downto 0);
signal clock_divider1_clk_out_sig: std_logic;
signal clock_divider1_counter: unsigned(7 downto 0);
signal controller_i2c1_n_s: t_enum_t_states_1;
signal controller_i2c1_p_s: t_enum_t_states_1;

begin

regi_data_num <= unsigned(regi_data);
regi_address_num <= unsigned(regi_address);
address_num <= unsigned(address);
read_data <= std_logic_vector(read_data_num);


SDA <= output_control1_tri_state_controller1_tri_out_driver;
SCL <= output_control1_open_drain_output1_dr;

TOP_LEVEL_I2C_SUCCESS_REG1_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (en_reg = '1') then
            success <= '0';
        else
            if (success_trigger = '1') then
                success <= '1';
            end if;
        end if;
    end if;
end process TOP_LEVEL_I2C_SUCCESS_REG1_LOGIC;


data_acquisition1_combiner_out <= unsigned'(address_num & rw);


data_acquisition1_i2c_addr_reg_out <= data_acquisition1_reg_data3_reg;

TOP_LEVEL_I2C_DATA_ACQUISITION1_REG_DATA3_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (clr_reg = '1') then
            data_acquisition1_reg_data3_reg <= to_unsigned(0, 8);
        elsif (en_reg = '1') then
            data_acquisition1_reg_data3_reg <= data_acquisition1_combiner_out;
        end if;
    end if;
end process TOP_LEVEL_I2C_DATA_ACQUISITION1_REG_DATA3_LOGIC;


data_acquisition1_reg_addr_out <= data_acquisition1_reg_data4_reg;

TOP_LEVEL_I2C_DATA_ACQUISITION1_REG_DATA4_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (clr_reg = '1') then
            data_acquisition1_reg_data4_reg <= to_unsigned(0, 8);
        elsif (en_reg = '1') then
            data_acquisition1_reg_data4_reg <= regi_address_num;
        end if;
    end if;
end process TOP_LEVEL_I2C_DATA_ACQUISITION1_REG_DATA4_LOGIC;


data_acquisition1_reg_data_out <= data_acquisition1_reg_data5_reg;

TOP_LEVEL_I2C_DATA_ACQUISITION1_REG_DATA5_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (clr_reg = '1') then
            data_acquisition1_reg_data5_reg <= to_unsigned(0, 8);
        elsif (en_reg = '1') then
            data_acquisition1_reg_data5_reg <= regi_data_num;
        end if;
    end if;
end process TOP_LEVEL_I2C_DATA_ACQUISITION1_REG_DATA5_LOGIC;

TOP_LEVEL_I2C_DATA_ACQUISITION1_MUX_3INPUT1_LOGIC: process (data_acquisition1_reg_addr_out, sel_sig, data_acquisition1_i2c_addr_reg_out, data_acquisition1_reg_data_out) is
begin
    case sel_sig is
        when "00" =>
            mux_out <= data_acquisition1_i2c_addr_reg_out;
        when "01" =>
            mux_out <= data_acquisition1_reg_addr_out;
        when others =>
            mux_out <= data_acquisition1_reg_data_out;
    end case;
end process TOP_LEVEL_I2C_DATA_ACQUISITION1_MUX_3INPUT1_LOGIC;

TOP_LEVEL_I2C_BIT_SELECTOR1_LOGIC: process (bit_select, mux_out) is
    variable value: std_logic;
begin
    value := mux_out(to_integer(bit_select));
    current_bit <= value;
end process TOP_LEVEL_I2C_BIT_SELECTOR1_LOGIC;

TOP_LEVEL_I2C_COUNTER1_OUTPUT_LOGIC: process (counter1_counter) is
begin
    if (counter1_counter >= 0) then
        bit_select <= resize(unsigned(counter1_counter), 3);
    else
        bit_select <= to_unsigned(0, 3);
    end if;
end process TOP_LEVEL_I2C_COUNTER1_OUTPUT_LOGIC;


count_rdy <= tern_op(cond => (counter1_counter = (- 1)), if_true => '1', if_false => '0');

TOP_LEVEL_I2C_COUNTER1_COUNT_LOGIC: process (i2c_clk) is
begin
    if falling_edge(i2c_clk) then
        if (count_en = '1') then
            if (counter1_counter > (- 1)) then
                counter1_counter <= (counter1_counter - 1);
            end if;
        else
            counter1_counter <= to_signed(7, 4);
        end if;
    end if;
end process TOP_LEVEL_I2C_COUNTER1_COUNT_LOGIC;

TOP_LEVEL_I2C_OUTPUT_CONTROL1_CHECK_ACK1_LOGIC: process (i2c_clk) is
begin
    if rising_edge(i2c_clk) then
        if (fsm_clr_ack = '1') then
            fsm_ack <= '0';
        else
            if (output_control1_read_bit = '0') then
                fsm_ack <= '1';
            else
                fsm_ack <= '0';
            end if;
        end if;
    end if;
end process TOP_LEVEL_I2C_OUTPUT_CONTROL1_CHECK_ACK1_LOGIC;


output_control1_mux_scl_out <= tern_op(cond => (fsm_sel = '0'), if_true => scl_internal, if_false => i2c_clk);


output_control1_mux_sda_out <= tern_op(cond => (fsm_sel = '0'), if_true => fsm_write, if_false => current_bit);

TOP_LEVEL_I2C_OUTPUT_CONTROL1_TRI_STATE_CONTROLLER1_CONTROL_OUT: process (SDA) is
begin
    if (SDA = '0') then
        output_control1_read_bit <= '0';
    else
        output_control1_read_bit <= '1';
    end if;
end process TOP_LEVEL_I2C_OUTPUT_CONTROL1_TRI_STATE_CONTROLLER1_CONTROL_OUT;

TOP_LEVEL_I2C_OUTPUT_CONTROL1_TRI_STATE_CONTROLLER1_INPUT_CONTROL: process (output_control1_mux_sda_out) is
begin
    if (output_control1_mux_sda_out = '1') then
        output_control1_tri_state_controller1_tri_out_driver <= 'Z';
    else
        output_control1_tri_state_controller1_tri_out_driver <= '0';
    end if;
end process TOP_LEVEL_I2C_OUTPUT_CONTROL1_TRI_STATE_CONTROLLER1_INPUT_CONTROL;

-- Open drain SCL output
TOP_LEVEL_I2C_OUTPUT_CONTROL1_OPEN_DRAIN_OUTPUT1_INPUT_CONTROL: process (output_control1_mux_scl_out, SCL) is
begin
    if ((output_control1_mux_scl_out = '0') and ((SCL = '1') or (SCL = '0') or (SCL = 'Z'))) then
        output_control1_open_drain_output1_dr <= '0';
    else
        output_control1_open_drain_output1_dr <= 'Z';
    end if;
end process TOP_LEVEL_I2C_OUTPUT_CONTROL1_OPEN_DRAIN_OUTPUT1_INPUT_CONTROL;


read_data_num <= output_control1_shift_reg_data1_reg;

TOP_LEVEL_I2C_OUTPUT_CONTROL1_SHIFT_REG_DATA1_LOGIC: process (i2c_clk) is
    variable val: unsigned(7 downto 0);
begin
    if rising_edge(i2c_clk) then
        if (sh_clr = '1') then
            output_control1_shift_reg_data1_reg <= to_unsigned(0, 8);
        elsif (sh_en = '1') then
            val := output_control1_shift_reg_data1_reg(8-1 downto 0);
            output_control1_shift_reg_data1_reg <= resize(unsigned'(val & output_control1_read_bit), 8);
        end if;
    end if;
end process TOP_LEVEL_I2C_OUTPUT_CONTROL1_SHIFT_REG_DATA1_LOGIC;


i2c_clk <= clock_divider1_clk_out_sig;

TOP_LEVEL_I2C_CLOCK_DIVIDER1_UPDATE_OUTPUT: process (clk) is
begin
    if rising_edge(clk) then
        if (clock_divider1_counter = 250) then
            if (i2c_clk_en = '1') then
                clock_divider1_clk_out_sig <= stdl((not bool(clock_divider1_clk_out_sig)));
            else
                clock_divider1_clk_out_sig <= '0';
            end if;
        end if;
    end if;
end process TOP_LEVEL_I2C_CLOCK_DIVIDER1_UPDATE_OUTPUT;

TOP_LEVEL_I2C_CLOCK_DIVIDER1_CNT_UPDATE: process (clk) is
begin
    if rising_edge(clk) then
        if (i2c_clk_en = '1') then
            if (clock_divider1_counter < 250) then
                clock_divider1_counter <= (clock_divider1_counter + 1);
            else
                clock_divider1_counter <= to_unsigned(0, 8);
            end if;
        else
            clock_divider1_counter <= to_unsigned(0, 8);
        end if;
    end if;
end process TOP_LEVEL_I2C_CLOCK_DIVIDER1_CNT_UPDATE;

TOP_LEVEL_I2C_CONTROLLER_I2C1_INPUT_DECODER: process (fsm_ack, count_rdy, start, i2c_clk, controller_i2c1_p_s) is
begin
    if ((controller_i2c1_p_s = IDLE) and (start = '1')) then
        controller_i2c1_n_s <= WF_START;
    elsif ((controller_i2c1_p_s = WF_START) and (start = '0')) then
        controller_i2c1_n_s <= START1;
    elsif ((controller_i2c1_p_s = START1) and (i2c_clk = '1')) then
        controller_i2c1_n_s <= START2;
    elsif ((controller_i2c1_p_s = START2) and (i2c_clk = '0')) then
        controller_i2c1_n_s <= SEND_ADDR;
    elsif ((controller_i2c1_p_s = SEND_ADDR) and (not bool(i2c_clk)) and bool(count_rdy)) then
        controller_i2c1_n_s <= CHECK_ACK_S0;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S0) and bool(i2c_clk) and bool(count_rdy)) then
        controller_i2c1_n_s <= CHECK_ACK_S1;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S1) and (not bool(i2c_clk))) then
        if (fsm_ack = '1') then
            controller_i2c1_n_s <= CHECK_ACK_S2;
        else
            controller_i2c1_n_s <= IDLE;
        end if;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S2) and bool(i2c_clk)) then
        controller_i2c1_n_s <= SEND_DATA_ADDRESS;
    elsif ((controller_i2c1_p_s = SEND_DATA_ADDRESS) and (not bool(i2c_clk)) and bool(count_rdy)) then
        controller_i2c1_n_s <= CHECK_ACK_S3;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S3) and bool(i2c_clk) and bool(count_rdy)) then
        controller_i2c1_n_s <= CHECK_ACK_S4;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S4) and (not bool(i2c_clk))) then
        if (fsm_ack = '1') then
            controller_i2c1_n_s <= CHECK_ACK_S5;
        else
            controller_i2c1_n_s <= IDLE;
        end if;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S5) and bool(i2c_clk)) then
        controller_i2c1_n_s <= SEND_DATA;
    elsif ((controller_i2c1_p_s = SEND_DATA) and (not bool(i2c_clk)) and bool(count_rdy)) then
        controller_i2c1_n_s <= CHECK_ACK_S6;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S6) and bool(i2c_clk) and bool(count_rdy)) then
        controller_i2c1_n_s <= CHECK_ACK_S7;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S7) and (not bool(i2c_clk))) then
        if (fsm_ack = '1') then
            controller_i2c1_n_s <= CHECK_ACK_S8;
        else
            controller_i2c1_n_s <= IDLE;
        end if;
    elsif ((controller_i2c1_p_s = CHECK_ACK_S8) and bool(i2c_clk)) then
        controller_i2c1_n_s <= STOP_S0;
    elsif ((controller_i2c1_p_s = STOP_S0) and (not bool(i2c_clk))) then
        controller_i2c1_n_s <= STOP_S1;
    elsif ((controller_i2c1_p_s = STOP_S1) and bool(i2c_clk)) then
        controller_i2c1_n_s <= IDLE;
    else
        controller_i2c1_n_s <= controller_i2c1_p_s;
    end if;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_INPUT_DECODER;

TOP_LEVEL_I2C_CONTROLLER_I2C1_MEMORY: process (clk, nrst) is
begin
    if (nrst = '0') then
        controller_i2c1_p_s <= IDLE;
    elsif rising_edge(clk) then
        controller_i2c1_p_s <= controller_i2c1_n_s;
    end if;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_MEMORY;

TOP_LEVEL_I2C_CONTROLLER_I2C1_READY_CONTROL: process (controller_i2c1_p_s) is
    variable cond_ack_0: std_logic;
    variable cond_ack_1: std_logic;
    variable cond_ack_2: std_logic;
begin
    cond_ack_0 := stdl((controller_i2c1_p_s /= CHECK_ACK_S0) and (controller_i2c1_p_s /= CHECK_ACK_S1) and (controller_i2c1_p_s /= CHECK_ACK_S2));
    cond_ack_1 := stdl((controller_i2c1_p_s /= CHECK_ACK_S3) and (controller_i2c1_p_s /= CHECK_ACK_S4) and (controller_i2c1_p_s /= CHECK_ACK_S5));
    cond_ack_2 := stdl((controller_i2c1_p_s /= CHECK_ACK_S6) and (controller_i2c1_p_s /= CHECK_ACK_S7) and (controller_i2c1_p_s /= CHECK_ACK_S8));
    fsm_clr_ack <= tern_op(cond => (bool(cond_ack_0) and bool(cond_ack_1) and bool(cond_ack_2)), if_true => '1', if_false => '0');
    if (controller_i2c1_p_s = IDLE) then
        ready <= '1';
    else
        ready <= '0';
    end if;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_READY_CONTROL;

TOP_LEVEL_I2C_CONTROLLER_I2C1_CLEAR_CONTROL: process (controller_i2c1_p_s) is
begin
    if (controller_i2c1_p_s = IDLE) then
        clr_reg <= '1';
        sh_clr <= '1';
    else
        clr_reg <= '0';
        sh_clr <= '0';
    end if;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_CLEAR_CONTROL;

TOP_LEVEL_I2C_CONTROLLER_I2C1_COUNT_CONTROL: process (controller_i2c1_p_s) is
begin
    if (controller_i2c1_p_s = IDLE) then
        count_en <= '0';
    elsif ((controller_i2c1_p_s = SEND_ADDR) or (controller_i2c1_p_s = SEND_DATA_ADDRESS) or (controller_i2c1_p_s = SEND_DATA)) then
        count_en <= '1';
    else
        count_en <= '0';
    end if;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_COUNT_CONTROL;

TOP_LEVEL_I2C_CONTROLLER_I2C1_REG_EN_CONTROL: process (controller_i2c1_p_s) is
begin
    if (controller_i2c1_p_s = WF_START) then
        en_reg <= '1';
    else
        en_reg <= '0';
    end if;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_REG_EN_CONTROL;

TOP_LEVEL_I2C_CONTROLLER_I2C1_I2C_CONTROL: process (controller_i2c1_p_s) is
begin
    case controller_i2c1_p_s is
        when IDLE =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '0';
        when START1 =>
            fsm_write <= '0';
            scl_internal <= '1';
            fsm_sel <= '0';
        when START2 =>
            fsm_write <= '0';
            scl_internal <= '1';
            fsm_sel <= '0';
        when SEND_ADDR =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '1';
        when CHECK_ACK_S0 =>
            fsm_write <= '1';
            scl_internal <= '0';
            fsm_sel <= '0';
        when CHECK_ACK_S1 =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '0';
        when CHECK_ACK_S2 =>
            fsm_write <= '0';
            scl_internal <= '0';
            fsm_sel <= '0';
        when SEND_DATA_ADDRESS =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '1';
        when CHECK_ACK_S3 =>
            fsm_write <= '1';
            scl_internal <= '0';
            fsm_sel <= '0';
        when CHECK_ACK_S4 =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '0';
        when CHECK_ACK_S5 =>
            fsm_write <= '0';
            scl_internal <= '0';
            fsm_sel <= '0';
        when SEND_DATA =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '1';
        when CHECK_ACK_S6 =>
            fsm_write <= '1';
            scl_internal <= '0';
            fsm_sel <= '0';
        when CHECK_ACK_S7 =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '0';
        when CHECK_ACK_S8 =>
            fsm_write <= '1';
            scl_internal <= '0';
            fsm_sel <= '0';
        when STOP_S0 =>
            fsm_write <= '0';
            scl_internal <= '0';
            fsm_sel <= '0';
        when STOP_S1 =>
            fsm_write <= '0';
            scl_internal <= '1';
            fsm_sel <= '0';
        when others =>
            fsm_write <= '1';
            scl_internal <= '1';
            fsm_sel <= '0';
    end case;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_I2C_CONTROL;

TOP_LEVEL_I2C_CONTROLLER_I2C1_OUTPUT_DECODER: process (controller_i2c1_p_s) is
begin
    case controller_i2c1_p_s is
        when START1 =>
            sel_sig <= to_unsigned(0, 2);
            success_trigger <= '0';
            sh_en <= '0';
            i2c_clk_en <= '1';
        when START2 =>
            sel_sig <= to_unsigned(0, 2);
            success_trigger <= '0';
            sh_en <= '0';
            i2c_clk_en <= '1';
        when SEND_DATA_ADDRESS =>
            sel_sig <= to_unsigned(1, 2);
            success_trigger <= '0';
            sh_en <= '0';
            i2c_clk_en <= '1';
        when SEND_DATA =>
            sel_sig <= to_unsigned(2, 2);
            success_trigger <= '0';
            sh_en <= '0';
            i2c_clk_en <= '1';
        when CHECK_ACK_S8 =>
            sel_sig <= to_unsigned(2, 2);
            success_trigger <= '1';
            sh_en <= '0';
            i2c_clk_en <= '1';
        when others =>
            sel_sig <= to_unsigned(0, 2);
            success_trigger <= '0';
            sh_en <= '0';
            i2c_clk_en <= '1';
    end case;
end process TOP_LEVEL_I2C_CONTROLLER_I2C1_OUTPUT_DECODER;

end architecture MyHDL;
